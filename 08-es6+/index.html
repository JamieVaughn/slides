<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <meta name="description" content="MCC Web Design & Development Slides" />
    <meta name="author" content="Jamie Vaughn" />
    <title>Template</title>
    <!-- Inspire css -->
    <link href="../lib/inspire.css" rel="stylesheet" />
    <link href="../lib/theme.css" rel="stylesheet" />
    <link href="../lib/talk.css" rel="stylesheet" />
    <link href="../lib/utils.css" rel="stylesheet" />

    <!-- Custom css -->
    <link rel="stylesheet" href="../laser/laser.css" />
    <script src="https://cdn.master.co/css"></script>
  </head>
  <body
    class="language-markup"
    data-prism-plugins="normalize-whitespace"
    data-duration="30"
  >
    <header id="intro" class="slide">
      <h1>ECMAScript Version 2015+</h1>
      <h2>ES6 & Beyond</h2>
      <p class="attribution">MCC: Section 2</p>
    </header>

    <section>
      <header class="slide">
        <h2>ECMAScript Version 2015+</h2>
        <h1>AKA Edition 6 or ES6</h1>
      </header>
      <article class="slide">
        <h2>ES6+ We've already Seen</h2>
        <div class="flex">
          <ul>
            <li class="delayed"><code>let</code>, <code>const</code></li>
            <li class="delayed">
              Nullish Coalescer <code>??</code>, Optional Chaining
              <code>?.</code>
            </li>
            <li class="delayed">
              Arrow Functions: <code>(x, y) => x + y</code>
            </li>
            <li class="delayed"><code>Symbol</code>, <code>BigInt</code></li>
            <li class="delayed">
              Ternary Operator: <code> condition ? true : false</code>
            </li>
            <li class="delayed">
              <pre class="language-js">
            <code>try {
  // ...
} catch(e) {
  // ...
} finally {
  // ...
}</code>
          </pre>
            </li>
          </ul>
          <ul>
            <li class="delayed">
              Array Methods:
              <ul>
                <li class="delayed">
                  <pre class="language-js"><code>.map
.flatMap
.filter
.reduce
.reduceRight
.some
.find
.every
.includes
// and many of the other array methods
              </code></pre>
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </article>
      <article class="slide">
        <h2>New ES6+ Features</h2>
        <ul class="col-2">
          <li class="delayed">String Template Literals & Tagged Templates</li>
          <li class="delayed">Default Parameters</li>
          <li class="delayed">Destructuring & Param Context matching</li>
          <li class="delayed">Rest & Spread operators</li>
          <li class="delayed">Object Propery/Method Shorthand</li>
          <li class="delayed">Computed Properties</li>
          <li class="delayed">Map, WeakMap, Set, WeakSet</li>
          <li class="delayed">Module Imports/Exports</li>
          <li class="delayed">Classes, Generators</li>
          <li class="delayed">Promise & fetch</li>
          <li class="delayed">Internationalization Utils</li>
          <li class="delayed">non-ES6 Extra: Currying/Closures</li>
        </ul>
      </article>
      <article class="slide">
        <h2>New Feature Resources</h2>
        <p>
          Concise Index of them at
          <a href="http://es6-features.org/">es6-features.org</a>
        </p>
        <p><a href="http://help.wtf/es6">ES6 help</a></p>
        <p>
          <a href="https://github.com/lukehoban/es6features#readme"
            >ES6 README</a
          >
        </p>
      </article>
      <article class="slide">
        <h2>
          🧵 String Template Literals
          <sup
            ><a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
              >MDN</a
            ></sup
          >
        </h2>
        <p>
          <strong>Multiline Strings: </strong>uses backticks
          <code>` `</code> (single or multi line)
        </p>
        <pre class="language-js"><code>let myStr = `This is
a fancy
multiline string`
		</code></pre>
        <p>
          <strong>String Interpolation:</strong> allows embeddable javascript
          expressions with the <code>${ }</code> syntax
        </p>
        <pre class="language-js"><code>let myVar = 'fancy'
let myFn = () => typeof myVar
let myStr = `This is
a ${myVar}
multiline ${myFn()}`
		</code></pre>
      </article>
      <article class="slide">
        <h2>
          🏷️ Tagged Template Functions
          <sup
            ><a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"
              >MDN</a
            ></sup
          >
        </h2>
        <p>
          You can create a special function from a template string literal which
          takes the template string as its parameters:
        </p>
        <pre class="language-js"><code>function myTag(string, person, job) {
  console.log(string, person, job)
}
let person = 'Jamie'
let job = 'developer'
myTag`That person's name is ${ person } and they are a ${ job }.`</code></pre>
        <p>
          It will provide as parameters the chunked string in an array, and the
          other parameters separately.
        </p>
      </article>
      <article class="slide">
        <h2>Default Parameters</h2>
        <p>
          If no value or undefined is passed, then initialize with a default
          value
        </p>
        <pre class="language-js"><code>function chatMsg(greeter, msg) {
  console.log(`${greeter}: ${msg}`)
}
function chatMsg2(greeter = 'Auto-greeter', msg = 'Hello') {
  console.log(`${greeter}: ${msg}`)
}
chatMsg("Joe", "What's up?") // "Joe: What's up?""
chatMsg() // 'undefined: undefined'
chatMsg2() // 'Auto-greeter: Hello'</code></pre>
      </article>
      <article class="slide">
        <h2>Hypothetical Use Case:</h2>
        <p>
          Use previous params or even functions in your default param expression
        </p>
        <pre
          class="language-js"
        ><code>const randNum = () => Math.random().toString().slice(3, 5)
function createUser(
  name,
  password, 
  username = name+randNum(),
  isAdmin = false
) {
  sendLoginData(user, password)
  setPermissions(isAdmin)
}
createUser('Joe', 'h2jq9fn48',)
createUser('Jay', 'y9i7h3ndk', undefined, true)
</code></pre>
      </article>
      <article class="slide">
        <h2>Destructuring</h2>
        <code>let { 🍞, 🥬, 🍅, 🧅, 🥓, 🧀, 🥩, 🍞 } = 🍔</code>
        <p>
          If you think about it, a bacon cheeseburger is a data structure
          because it's just a list of its own ingredients.
        </p>
        <p>
          Arrays & Objects are essentially just lists, too. Destructuring lets
          us unpack arrays or objects into their distinct consituent elements
          and save them into variables on the parent scope.
        </p>
        <ul>
          <li class="delayed">Array Destructuring</li>
          <li class="delayed">Object Destructuring</li>
          <li class="delayed">Parameter Context matching</li>
        </ul>
        <p class="delayed">
          It's kinda magical 
        </p>
        <pre class="language-js delayed"><code>// destructure the magic & the horse from a unicorn
let { ✨, 🐴 } = 🦄</code></pre>
      </article>
      <article class="slide">
        <h2>Object Destructuring</h2>
        <code>const { 🍞, 🥬, 🍅, 🧅, 🥓, 🧀, 🥩, 🍞 } = 🍔</code>
          <pre class="language-js"><code>const burger = {
  topBun: 'sourdough',
  condiment: 'ketchup',
  lettuce: 'iceberg',
  tomato: 'beefsteak',
  bacon: 2,
  cheese: 'cheddar',
  burger: 'angus',
  bottomBun: 'sourdough'
}

// destructure properties as needed into global namespace
// & provide alternate identifiers to avoid naming collisions
const { tomato, bacon, cheese, burger: patty } = burger 
</code></pre>
      </article>
      <article class="slide">
        <h2>Array Destructuring</h2>
        <pre class="language-js"><code>var list = [ 1, 2, 3 ]
var [ a, , b ] = list

// We can avoid needing a temp var when swapping
[ b, a ] = [ a, b ]

// can also use default assignment here
let [d, e, f, g=7] = list </code></pre>
      </article>
      <article class="slide">
        <h2>Common Use Case</h2>
        <p>
          Destructuring Config Objects to extract just the properties you need.
        </p>
        <pre class="language-js"><code>const user = {
  user: 'jdoe', 
  email: 'jdoe@home.com'
  fullName: {
    first: 'John',
    last: 'Doe'
  }
};

let { email, fullName: { first } } = user
let myStr = `${first}'s email is ${email}`;

console.log(myStr);  // "John's email is jdoe@home.com"</code></pre>
      </article>
      <article class="slide">
        <h2>Default Value Assignment for Destructuring</h2>
        <p>Available to use for either Objects or Arrays</p>
        <pre class="language-js"><code>var list = [ 7, 42 ]
var [ a = 1, b = 2, c = 3, d ] = list
console.log(a, b, c, d) // 7, 42, 3, undefined</code></pre>
<pre class="language-js"><code>const burger = { /* ...previous values... */}
const { tomato, bacon, onion, pickles = 'dill' } = burger
console.log(tomato, bacon, onion, pickles) 
// ↳ 'beefsteak', 2, undefined, 'dill'
</code></pre>
      </article>
      <article class="slide">
        <h2>Parameter Context Matching</h2>
        <p>You can think of this as destructuring for parameters</p>
        <p>
          Handy when you need just a couple of values in an object/array
          parameter.
        </p>
        <pre class="language-js"><code>function f ([ name, val ]) {
  console.log(name, val)
}
let arr = ['John', '#42']
f(arr) // logs: 'John', '#42'

function g ({ name: n, val: v }) {
  console.log(n, v)
}
let obj = {name: 'John', val: '#42'}
g(arr) // logs: 'John', '#42'</code></pre>
      </article>
      <article class="slide">
        <h2>Using Destructuring With Default params</h2>
        <p>✨ Combine these for super powers! ✨</p>
        <pre class="language-js"><code>function f([x = 1, y = 2]) {
  return x + y
}
f([])  // 3
f() // Type Error, won't work without the array

function g({a, b = 2}) {
  let ap = a ?? 0 // Nullish Coalescer can guard undefined
  return ap + b
}
g({a: 4})  // 6
g() // Type Error, won't work without the object</code></pre>
      </article>
      <article class="slide">
        <h2>Rest & Spread Operators</h2>
        <code>...</code>
        <p>
          <u>Rest</u>: to gather up <strong>the rest</strong> of the values into
          an Array or Object. Used in function parameters.
        </p>
        <p>
          <u>Spread</u>: to <strong>spread out</strong> encapsulated values into
          loose values. Used on arrays and objects.
        </p>
        <p>
          <small
            ><u>encapsulated</u> here means that the values are contained in an
            object or an array.</small
          >
        </p>
      </article>
      <article class="slide">
        <h2>Rest</h2>
        <p>
          Used in for function parameters to create a
          <u>Variadic</u> function (a function that accepts a varying number of
          parameters)
        </p>
        <p>
          Function <u>Arity</u>: The number of parameters a function accepts
          (see <code>Function.length</code>)
        </p>
        <pre
          class="language-js"
        ><code>function addFirstTwo(a, b, ...manyMoreArgs) {
  return a + b
}
addFirstTwo([1,1,5,6,7]) // 2 </code></pre>
      </article>
      <article class="slide">
        <h2>Object Spread</h2>
        <pre class="language-js"><code>const names1 = {cat: 'Bob'}
const names2 = {dog: 'Fred', alligator: 'Benedict'}
const copy = { ...names2 } // Avoid pass by Reference trouble
const newNames = { ...names1, ...names2 };</code></pre>
      </article>
      <article class="slide">
        <h2>Array Spread</h2>
        <pre class="language-js"><code>var arr = [1, 2, 3]
var arr2 = [...arr] // copy of arr
var arr3 = arr.slice() // also a copy of arr</code></pre>
        <p>
          It can be used to create a copy of an array, similar to
          <code>.slice()</code>
        </p>
      </article>
      <article class="slide">
        <h2>Object Property & Method Shorthand</h2>
        <ol style="margin: 0 auto 0 4rem;"><strong>Method Shorthand uses Function Declaration but it:</strong>
          <li>omits the colon & the <code>function</code> keyword</li>
          <li>preserves the local value of<code>this</code></li>
        </ol>
        <div class="flex">
        <pre class="language-js"><code>let shout = (pet) => console.log(pet.toUpperCase() + '!!!')
let cat = 'meow';
let dog = 'woof';

let myPets = {
  shout, // arrow functions written like properties
  cat,
  dog,
  speak (pet) { // function declaration shorthand
    console.log(this[pet])
  }
}

myPets.speak(myPets.cat) // 'Meow'</code></pre>
<pre class="language-js"><code>// It's a bit shorter...


// than the old syntax:
let myPets = {
  shout: shout
  cat: cat, 
  dog: dog, 
  speak: function (pet) {
    console.log(this[pet])
  }
} </code></pre>
</div>
      </article>
      <article class="slide">
        <h2>Computed Properties</h2>
        <pre class="language-js"><code>let makeKey = key => key;
let key = 'key'
// Before was done one by one like this:
let obj = {};
obj[key] = 'value';

// Now can be done in bulk:
let computedObj = {
  [key]: 'value',
  [makeKey('string')]: 'value',
  [makeKey('name')]: 'value'
}</code></pre>
      </article>
      <article class="slide">
        <div class="flex" style="align-items: center">
          <h2 class="bumpup">
            Map
            <sup
              ><a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
                >MDN</a
              ></sup
            >
          </h2>
          <ul><strong>Use Maps over objects when:</strong>
            <li>its properties will be changing frequently</li>
            <li>you need the <code>size</code> property</li>
            <li>you need the properties to preserve their order.</li>
            <li>Keys can be any value, not just Strings or Symbols.</li>
            <li>There are no prototype keys, which can simplify looping</li>
          </ul>
        </div>
        <div class="flex">
          <pre class="language-js"><code>const myMap = new Map()
myMap.set('key', 'value')
myMap.set(true, 'value')
let func = key => null
myMap.set(func, 100)
myMap.has(func) // true
let obj = {a: 'A'}
myMap.set(obj, 'B')
myMap.get(obj) // 'B'
myMap.size // 3
myMap.delete('key') // true
myMap.clear() // deletes all
// initializing a Map with an array of entries (tuples):
const initMap = new Map([ 
  ['dog', 'woof'],
  ['cat', 'meow'],
]); </code></pre>
          <pre class="language-js"><code>// Looping over a Map
// ✅ Using forEach OR for ... of
map1.forEach((value, key) => {
  console.log(value, key); // woof dog, meow cat
});
for (const [key, value] of map1) {
  console.log(key, value); // dog woof, cat meow
}

// ✅ Iterate over a Map's keys OR values
for (const key of map1.keys()) {
  console.log(key); // dog, cat
}
for (const value of map1.values()) {
  console.log(value); // woof, meow
}</code></pre>
        </div>
      </article>
      <article class="slide">
        <h2>
          Set
          <sup
            ><a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
              >MDN</a
            ></sup
          >
        </h2>
        <p>Sets may only contain one of any particular value.</p>
        <p>
          This makes them convenient as a way to remove duplicates in an array.
        </p>
        <pre
          class="language-js"
        ><code>const numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,5,3,4,5]
const noDupes = [...new Set(numbers)] // [2,3,4,5,6]</code></pre>
        <pre class="language-js"><code>const mySet = new Set()
mySet1.add(5)          
mySet1.add('some text')            
mySet1.add({a: 1, b: 2})
mySet1.has(5) 
mySet1.size  // 3
mySet1.delete(5)     
		</code></pre>
      </article>
      <article class="slide">
        <h2>More on Keyed Collections</h2>
        <p>
          Map, WeakMap, Set & WeakSet are all <strong>Keyed Collections</strong>
        </p>
        <p>
          Refer to this
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections"
            >article</a
          >
          for more on when to use each one
        </p>
        <ul>
          <li>Map has a less common twin: WeakMap</li>
          <li>The less common <code>WeakMap</code> has same API, except keys can only be objects or functions:</li>
          <li>Set has a less common twin: WeakSet</li>
        </ul>
        <pre class="language-js"><code>const myWeakMap = new WeakMap()
const myWeakSet = new WeakSet()
        </code></pre>
        <details class="notes">
          <p>
            <code>WeakMap</code> may not be that useful. It's called "Weak"
            because it allows garbage collection.
          </p>
        </details>
      </article>
    </section>

    <section>
      <header class="slide">
        <h2>Code Organization Techniques</h2>
        <h1>Modules, Closures & Classes</h1>
      </header>

      <article class="slide">
        <h2>Code Encapsulation</h2>
        <p>We'll learn about three ways to encapsulate our code</p>
        <ul class="delayed-chidren">
          <li><strong>Modules</strong>
            <ul>
              <li><small>based on files</small></li>
            </ul>
          </li>
          <li><strong>Closures</strong>
            <ul>
              <li><small>based on functions</small></li>
            </ul>
          </li>
          <li><strong>Classes</strong>
            <ul>
              <li><small>based on classes (new in es6+)</small></li>
            </ul>
          </li>
        </ul>
        <p style="padding: 0 10rem;">All of these let us wrap our code inside of a "black box" so we can expose only the parts of it that we deliberately intend to and we can keep the nitty gritty implementation details hidden & inaccessible inside. </p>
      </article>

      <article class="slide">
        <h2>Modules 📦</h2>
        <p>Little packages for our code</p>
        <ul class="delayed-children">
          <li>Modules provide a new way to organize our code into manageable chunks.
          <li>By using the <code>import</code> & <code>export</code> keywords, we can modularize code &
            organize it <u>into a unit defined by a file.</u></li></li>
          <li>Modules wrap up parts of your code into easily resusable pieces</li>
          <li>Modules makes those pieces of code easily composed together</li>
        </ul>
      </article>
      <article class="slide">
        <h2>A simple single file Module</h2>
        <pre class="language-js"><code>import myArr from './data.js'

const power = 3

function module(arr) {
  let biggerArr = myArr.concat(arr)
  return biggerArr.map(item => item ** power)
}
  
export default module</code></pre>
      </article>
      <article class="slide">
        <h2>Export & Import</h2>
        <ul>
          <li>Export is used when creating JavaScript modules to export functions,
            objects, or primitive values from the module so they can be used by
            other programs with the import statement.</li>
          <li>Import is used to import bindings (i.e. functions, vars, etc) which
            are exported by another module.</li>
          <li>This will come in handy with React & other frameworks</li>
          <li>But we can also take advantage of this for own code organization</li>
        </ul>
      </article>
      <article class="slide">
        <h2>Export Syntax</h2>
        <pre class="language-js"><code>export let name1, name2, …,;
export const name1 = …, name2 = …, …;
export function functionName(){...}
export class ClassName {...}
// Defaults
export default expression;
export default function (…) { … }</code></pre>
      </article>
      <article class="slide">
        <h2>Import Syntax</h2>
        <pre class="language-js"><code>import defaultExport from "module-name.js";
import * as name from "module-name.js";
import { export1 } from "module-name.js";
import { export1 as alias1 } from "module-name.js";
import { export1 , export2 } from "module-name.js";</code></pre>
      </article>
      <article class="slide">
        <h2>
          Closures
          <sup
            ><a href="https://www.w3schools.com/js/js_function_closures.asp"
              >W3</a
            >,
          </sup>
          <sup
            ><a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
              >MDN</a
            ></sup
          >
        </h2>
        <p style="padding: 0 10rem">
          Before Modules, code encapsulation was accomplished with the
          <a
            href="https://www.codeproject.com/Articles/1164113/Module-and-Revealing-Module-Patterns-in-JavaScript"
            >Revealing Module Pattern</a
          >
          using IIFEs
        </p>
      </article>
      <article class="slide">
        <h2>Closure Building Blocks</h2>
        <ol>
          <li>Scope (Global vs. Local)</li>
          <li>Nested Functions</li>
          <li>Currying: Returning an Inner Function</li>
        </ol>
        <pre class="language-js"><code>// Local vs Global
function fn() {
  let base = 9
  var power = 2 // even var is local to a function scope
}
console.log(power, base) // Reference Error
// Nesting & Returning Functions 
function gn() {
  let temp = 9
  var power = 2
  return function() {
    temp * power
  }
}</code></pre>
      </article>
      <article class="slide">
        <h2>Closures Illustration</h2>
        <p>
          <strong>Global variables are long-lived</strong>: until page is
          discarded (navigate away, close)
        </p>
        <p>
          <strong>Local variables are short-lived</strong>: Function invocation
          creates them, <br />
          Function Return destroys them (garbage collected)
        </p>
        <pre class="language-js"><code>for (var i = 1; i &lt;= 4; i++) {
  setTimeout(function() { 
    console.log(i)
  }, 1000*i)     // 5 5 5 5
}
for (var i = 1; i &lt;= 4; i++) {
  setTimeout(function(x) { 
    return () =&gt; console.log(x) 
  }(i), 1000*i)
// 1 2 3 4
}</code></pre>
      </article>
      <article class="slide">
        <h2>
          Block Scope Fix with <code>let</code>, <code>const</code>,
          <code>.forEach</code>
        </h2>
        <pre class="language-js"><code>for (let i = 1; i &lt;= 4; i++) {
  setTimeout(function() { 
    console.log(i)
  }, 1000*i)     // 1 2 3 4
}</code></pre>

        <pre class="language-js"><code>[...Array(4).keys()].forEach(i =&gt; {
  setTimeout(function() { 
    console.log(i)
  }, 1000*i) // 0 1 2 3
})</code></pre>
      </article>
      <article class="slide">
        <h2>Simple Curried Function</h2>
        <pre class="language-js"><code>let fn = x =&gt; y =&gt; x + y
// let fn = (x) =&gt; (y =&gt; x + y)
let n = fn(3)
// Some indefinite amount of time may pass, then:
n(4) // 7

// Could also be invoked at once:
fn(3)(4) // 7</code></pre>
        <p>
          Due to referential transparency, these are identical evaluations,
          despite difference in time.
        </p>
      </article>
      <article class="slide">
        <h2>The same curried function written 4 ways</h2>
        <pre class="language-js"><code>const add = x =&gt; y =&gt; x + y

const add = x =&gt; { 
    return y =&gt; {
        return x + y
    }
}

function add(x) {
    return function(y) {
      return x + y
  }
}

// calling add:
const partial = add(1) // return a function with 1 in its closure
const continuation = partial(2) // returns 3, because it added 1 from above with 2
</code></pre>
      </article>
      <article class="slide">
        <h2>Parallel Closures</h2>
        <p>
          Curried Functions allow us to reuse code by creating
          <strong>Parallel Closures</strong>.
        </p>
        <p>
          Closures can create multiple instances of closed over variables that
          are independent of each other.
        </p>
        <img src="img/parallel_closures.png" alt="" />
      </article>
      <article class="slide">
        <h2>Closures & Modules Code Along</h2>
      </article>
    </section>

    <section>
      <header class="slide">
        <h2>Code Encapsulation</h2>
        <h1>Intro to JS Classes</h1>
      </header>
      <article class="slide">
        <h2>Object Oriented Patterns</h2>
        <p>
          ES6 classes are a syntactic sugar over the prototype-based OO pattern.
          It's not <strong>true</strong> Classical Inheritance that other languages have (like Java)
        </p>
        <p>
          Having a single convenient declarative form makes class patterns
          easier to use, and encourages interoperability.
        </p>
        <p>
          Classes support prototype-based inheritance, <code>super</code> calls,
          instance/static methods, constructors and finally private identifiers.
        </p>
      </article>
      <article class="slide">
        <h2>Javascript <code>Class</code> Keyword</h2>
        <div class="flex">
        <pre class="language-js"><code>class Point2D {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  // ...define more variables and methods here
}

const instanceXYPoint = new Point2D(1, 2)
instanceXYPoint.x // 1
instanceXYPoint.y // 2
</code></pre>
        <ul>
          <li>Constructor/Super <ul>
            <li><code>constructor</code></li>
            <li><code>super</code></li>
            <li>Instantiating with the <code>new</code> keyword</li>
          </ul></li>
          <li>Getters/Setters 
            <ul>
              <li><code>get</code></li>
              <li><code>set</code></li>
            </ul>
            </li>
          <li>Private members with the hash symbol 
            <ul>
              <li><code>#</code></li>
            </ul>
            </li>
          <li>Prototypal Inheritance</li>
        </ul>
      </div>

      </article>
      <article class="slide">
        <h2>Made Possible by Enhance Object Literals</h2>
        <pre class="language-js"><code>var obj = {
  // set a custom __proto__
  __proto__: theProtoObj, // the constructor
  // Methods
  toMyString() {
    // Super calls
    return "My " + super.toString();
  }
}
obj.toMyString() // 'My [object Object]'
obj.toString() // '[object Object]'</code></pre>
        <p>
          Along with property shorthand & computed properties, these also bring
          object literals and class declarations closer together, and allow
          object-based design to benefit from some of the same conveniences
        </p>
      </article>
      <article class="slide">
        <h2>Not your Java's Inheritance</h2>
        <p>
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model"
            >Classical vs Prototypal Inheritance</a
          >
        </p>
        <p>
          They lack the classical inheritance model like other OOP language
          classes
        </p>
        <p>They use Prototypal Inheritance just like Objects.</p>
      </article>
      <article class="slide">
        <h2>Typical Class Declaration</h2>
        <pre class="language-js"><code>class Vegetable {
  constructor(name){
    this.name = name
  }
}
const carrot = new Vegetable('carrot');
console.log(carrot.name); // 'carrot'</code></pre>
      </article>
      <article class="slide">
        <h2>Equivalent Function</h2>
        <pre class="language-js"><code>function vegetable(name) {
  return {
    name
  }
}
const carrot = vegetable('carrot')
console.log(carrot.name) // 'carrot'</code></pre>
      </article>
      <article class="slide">
        <h2>Get and Set</h2>
        <pre class="language-js"><code>class TempConverter {
  constructor(F) {
    this.F = F;
  }
  get boilsWater() {
    return this.F &gt;= 212;
  }
  get C () {
    return (5 / 9) * (this.F - 32)
  }
  set C (degrees) {
    this.F = (degrees * 9.0) / 5 + 32;
  }
} // can't use arrow function syntax for getters/setters because of lexical scoping</code></pre>
      </article>
      <article class="slide">
        <h2>Class Example</h2>
        <pre class="language-js"><code>class Person {
  constructor(name, email, address) {
    this.name = name
    this.email = email
    this.address = address
  }
  getInfo() {
    return {
      Name: this.name, 
      Email: this.email, 
      Address: this.address
    }
  }
}</code></pre>
      </article>
      <article class="slide">
        <h2>Extending Classes</h2>
        <pre class="language-js"><code>class Employee extends Person {
  constructor(job, address, ...args) {
    // super is a link w/ Parent Class
    super(...args) // calls parent w/ rest of args
    this.job = job
    this.address = address // Can overwrite parent properties
    // such as with the work address here
  }
  getInfo() { // Can overwrite methods too
    return {
      Name: this.name, 
      Email: this.email,
      Address: this.address, 
      Job: this.job 
    }
  }
}
</code></pre>
      </article>
      <article class="slide">
        <h2>What is <code>super</code></h2>
        <ul>
          <li>
            <code>super</code> maintains the connection between parent and child
            classes - It establishes the inheritance chain.
          </li>
          <li><code>super</code> method is used to call parent's constructor & populates the class with all of it's parents properties & methods</li>
          <li>
            It is optional to use it - only if you need to use
            properties/methods of your parent class in your derived class
          </li>
          <li>
            You can create a class without a constructor, but it will use a
            default one
          </li>
        </ul>
        <pre class="language-js"><code>// default will inherit from Object
constructor() {}

// For the derived class, if you don't specify a constructor, it will use
constructor(...args) {
  super(...args);
}</code></pre>
      </article>
      <article class="slide">
        <h2>Results</h2>
        <div class="flex" style="gap: 3rem;">
        <pre class="language-js"><code>const joPerson = new Person(
  "Jo", "jo@home.com", "123 Home Ave"
)
const joEmployee = new Employee(
  "Developer", "321 Work Ave", "Jo", "jo@work.com"
)
</code></pre>
<div>
  <pre class="language-js"><code>console.table({
  emp: joEmployee.getInfo(), 
  per: joPerson.getInfo()
})
  </code></pre>
  <img src="img/employee.png" alt=""/>
</div>
      </div>
      </article>
      <article class="slide">
        <h2>Instances</h2>
        <p>For determining or asserting the chain of inheritance</p>
        <p>Binary Operator: <code>instanceof()</code></p>
        <pre class="language-js"><code>const joEmployee = new Employee(
  "Developer", "321 Work Ave", "Jo", "jo@work.com"
)
joEmployee instanceof Person // true

// OR check the __proto__ property (references the parent)
joEmployee.__proto__ // Person {constructor: ƒ, getInfo: ƒ}</code></pre>
      </article>
      <article class="slide">
        <h2>Private methods/properties <sup><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields">MDN</a></sup></h2>
        <p>Private members on a class are fully protected and inaccessible, except within the class block scope</p>
        <div class="flex">

        
        <pre class="language-js"><code>class ClassWithPrivate {
  #privateField = 42;
  #privateMethod() {
    console.log("can't access me directly")
    return this.#privateField
  }
  logPrivateMethod() {
    console.log(this.#privateMethod())
  }
}</code></pre>
<pre class="language-js"><code>const instance = new ClassWithPrivate()

// Public members can be access, called or deleted
instance.logPrivateMethod() // works

// Private members can't be accessed nor deleted
instance.#privateField === 42 // Syntax Error
instance.#privateMethod() // Syntax Error
delete instance.#privateMethod() // Syntax Error</code></pre>
</div>
      </article>
      <article class="slide">
        <h2>The <code>static</code> Keyword</h2>
        <p>For running some procedural code once for a class & sharing it between instances</p>
        <pre class="language-js"><code>class ClassWithPrivateStatic {
  static field = 'some value'
  static method () {
    return 42;
  }

  static {
    // …setup code to run once
  }
}</code></pre>
<p>Code in a <code>constructor</code> runs once per instance, while code in a <code>static</code> block runs once per class declaration.</p>
      </article>
      <article class="slide">
        <h2>Prototypal Inheritance</h2>
        <div class="flex" style="gap: 1rem">
          <img src="img/prototype_chain.png" alt="" style="max-height: 70vh;" />
          <div>
            <strong>Steps to access inherited properties in JS:</strong>
            <ol style="font-size: 2rem; line-height: 3.5rem">
              <li>
                Check if the key exists locally. If it does, return local value.
              </li>
              <li>
                If there is no local key, check up the prototype chain
                <br />(via the <code>__proto__</code> property).
              </li>
              <li>
                Iterate up the prototype chain looking for the next object w/
                the specified key
              </li>
              <li>
                For the first object encountered in the prototype chain w/ the
                key, return that key's value.
              </li>
              <li>
                If the key is not found in entire prototype chain, return
                undefined.
              </li>
            </ol>
          </div>
        </div>
      </article>
      <article class="slide">
        <h2>Compostion vs Inheritance</h2>
        <div class="flex" style="align-items: center">
          <ul>
            <li>
              The functional programming paradigm prefers composition over
              inheritance
            </li>
            <li>
              Composition means simply <strong>Composing Functions</strong>
            </li>
            <li>Composition is a more modular & flexible approach</li>
            <li>With inheritance you often inherit more than needed</li>
            <li>
              In general, with deeply nested inheritance chains, you're gonna
              have a bad time & end up overwriting a lot
            </li>
          </ul>
          <a href="http://www.johndcook.com/blog/2011/07/19/you-wanted-banana/" style="text-align: center;">
            <div>If you ask for a banana...</div>
            <img
              src="http://www.johndcook.com/gorilla_holding_banana.jpg"
              alt=""
            />
          </a>
        </div>
      </article>
    </section>

    <footer class="slide" title="The End">Thank you!</footer>

    <script src="../lib/inspire.js"></script>
    <script src="../laser/laser.js"></script>
  </body>
</html>
