<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="MCC Web Design & Development Slides">
	<meta name="author" content="Jamie Vaughn">
  <title>Redux</title>
  <!-- Inspire css -->
	<link href="../lib/inspire.css" rel="stylesheet" />
	<link href="../lib/theme.css" rel="stylesheet" />
	<link href="../lib/talk.css" rel="stylesheet" />
	<link href="../lib/utils.css" rel="stylesheet" />

  <!-- Custom css -->
</head>
<body class="language-markup" data-prism-plugins="normalize-whitespace" data-duration="30">

<header id="intro" class="slide">
  <h1>
    Web Design & Development
  </h1>
  <h2>
    Redux
  </h2>
  <p class="attribution">MCC: Section 3</p>
</header>
<section>    
  <header class="slide">
    <h2>Redux</h2>
		<h1>The Leading <strong>State Managment</strong> Library for React Apps</h1>
  </header>

	<article class="slide" title="">
    <h2>Why do we need Redux?</h2>
    <p>Web Apps are getting more complex: <strong><a href="https://redux.js.org/understanding/thinking-in-redux/motivation">The motivation</a></strong></p>
    <blockquote>As the requirements for JavaScript single-page applications have become increasingly complicated, our code must manage more state than ever before. This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. UI state is also increasing in complexity, as we need to manage active routes, selected tabs, spinners, pagination controls, and so on.</blockquote>
    <blockquote>Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have lost control over the when, why, and how of its state. When a system is opaque and non-deterministic, it's hard to reproduce bugs or add new features.</blockquote>
	</article>

  <article class="slide">
    <h2>Mutation & Asynchronicity</h2>
    <p><strong>This complexity is difficult to handle as we're mixing two concepts that are very hard for the human mind to reason about: mutation and asynchronicity.</strong></p>
    <ul>
      <li>What if we could make mutations seem like immutable copy-on-updates?</li>
      <li>What if we could make asynchronous operations seem like synchronous ones?</li>
    </ul>
  </article>

  <article class="slide">
    <h2>State Accessible from Anywhere</h2>
    <div class="flex">
      <img src="img/global_state.png" alt="">
      <p>We could have the state stored in a global container, which would allow components to access state from any position in the component tree. But this can cause problems because any component can access any part of the state. transient stateful bugs, because there’s no rules for accessing or writing to the global state.</p>
    </div>
  </article>

	<article class="slide">
    <h2>Is the Context API really state management?</h2>
    <p><a href="https://blog.isquaredsoftware.com/2021/01/context-redux-differences/">Article on the differences</a></p>
    <blockquote>Context is more like hidden props than abstracted state. - Mark Erikson</blockquote>
    <blockquote>Context is how state (that exists somewhere already) is shared with other components.
      <br>Context has little to do with state management. - David Khourshid</blockquote>
    <p>Context API is specific to the React API. Redux is more of a design pattern and since it is a separate library that can be used in any app.</p>
    <p>Both Context & Redux allow us to avoid prop drilling, but the similarities pretty much end there.</p>
	</article>
  <article class="slide">
    <h2>Context vs. Redux</h2>
    <di class="flex align most-height">
      <ul style="flex-shrink: 1.1">
        <li class='nolist'><strong>Context</strong></li>
        <li>Does not create a store. You have to give it one.</li>
        <li>Reads the Provider value</li>
        <li>Passes down a single value. Distinguishing bewteen different state requires separate Contexts.</li>
        <li>Limited support in React Dev Tools</li>
        <li>Difficult to skip updates of consuming component</li>
        <li>Doesn't handle side effects or async</li>
      </ul>
      <ul>
        <li class='nolist'><strong>Redux</strong></li>
        <li>Stores/manages singleton object</li>
        <li>Reads singleton object</li>
        <li>Mutates state with dispatch/action/reducer pattern</li>
        <li>Extensive custom Redux Dev Tools support</li>
        <li>Accomodates middleware for side effects & async ops</li>
        <li>Offers component subscriptions to subset of the store</li>
        <li>Only rerenders the component that is affected by the store update, not the whole component tree.</li>
      </ul>
    </di>
  </article>
  <article class="slide">
    <h2>useContext + useReducer</h2>
    <ul>
      <li>Using these in combination can start to approach a state management system</li>
      <li>But still rerenders the whole Provider sub-tree</li>
      <li>Still lacks natural way to handle async side effects</li>
    </ul>
  </article>
  <article class="slide">
    <h2>Summary</h2>
    <ul>
      <li>Context:
        <ul>
          <li>Passing down a value to nested components without prop-drilling</li>
        </ul>
      </li>
      <li>useReducer
        <ul>
          <li>Moderately complex React component state management using a reducer function</li>
        </ul>
      </li>
      <li>Context & useReducer
        <ul>
          <li>Moderately complex React component state management using a reducer function, and passing that state value down to nested components without prop-drilling</li>
        </ul>
      </li>
      <li>Redux
        <ul>
          <li>Sophisticated state management layer (independent of UI) using reducer functions</li>
          <li>Fantastic app date/error traceability over time</li>
        </ul>
      </li>
    </ul>
  </article>

  <article class="slide">
    <h2>Flux Architecture & Redux</h2>
    <p>Store - View - Dispatcher/Reducer</p>
    <img src="img/flux_pattern.png" alt="">
  </article>

  <article class="slide">
    <h2>Three Principles</h2>
    <p><a href="https://redux.js.org/understanding/thinking-in-redux/three-principles">Redux can be summarized as three fundamental principles:</a></p>
    <ul>
      <li>Single Source of Truth: <ul class='nolist'>
          <li><strong>A single store</strong></li>
        </ul> 
      </li>
      <li>State is read-only: 
        <ul class='nolist'>
          <li><strong>read-only store</strong></li>
          <li><strong>UI emits actions</strong></li>
        </ul> 
      </li>
      <li>Dispatched actions update Store via pure functions: 
        <ul class='nolist'>
          <li><strong>use pure reducers</strong></li>
        </ul>
      </li>
    </ul>
  </article>

  <article class="slide">
    <h2>Redux Schematic</h2>
    <p>The Synchronous Update Cycle</p>
    <img src="img/Redux.png" alt="">
  </article>

  <article class="slide">
    <h2>Action -> Dispatch -> Reducer</h2>
    <div class="flex" style='width: 90%'>
      <span>Define the App's <br>Actions</span>
      <p style='text-align: right;'>Define the Reducer logic <br>to Handle the Actions</p>
    </div>
    <div class="flex">
      <img src="img/wood-shape-match-.jpg" alt="">
      <pre class="language-sh"><code>redux
  ⌙ actions.js
  ⌙ reducers.js
  ⌙ store.js
      </code></pre>
      <img src="img/Wooden-Shape-Match.webp" alt="">
    </div>
  </article>
  <article class="slide">
    <h2>Add Any Actions Easily</h2>
    <p>Pass an "enum" (string) to trigger any arbitrary app logic. Mold the action & reducer logic in a flexible way.</p>
    <div class="flex">
      <img src="img/boy_carving.avif" alt="">
      <img src="img/cat_carving.jpg" alt="">
    </div>
  </article>

  <article class="slide">
    <h2>Store & Actions & Reducers</h2>
    <pre class="language-js"><code>const store = { count: 0 }

const action = {
  type: 'increment', // type is required
  data: 1 // optionally, pass any other data that's needed for the operation
}

const reducer = (state, action) => {
  switch(action.type) {
    case 'increment':
      return { state: state.count + action.data }
    case 'decrement':
      return { state: state.count - action.data }
    default:
      return state
  }
}

    </code></pre>
  </article>
  
  <article class="slide">
    <h2>Redux Core-team Recommendations</h2>
    <p><a href="https://redux.js.org/style-guide/style-guide#use-redux-toolkit-for-writing-redux-logic">Redux Style Guide</a></p>
  </article>
  <article class="slide">
    <h2>Redux Dev Tools</h2>
    <p><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Download the extension here</a></p>
  </article>
  <article class="slide">
    <h2>React-Redux Library</h2>
    <p><a href="https://react-redux.js.org/introduction/getting-started">Docs</a></p>
    <p>React Redux is the official React UI bindings layer for Redux. It lets your React components read data from a Redux store, and dispatch actions to the store to update state.</p>
  </article>
  <article class="slide">
    <h2>Code Along</h2>
    <p>Let's try out Redux in a simple Counter App!</p>
    <hr>
    <p>Let's use Redux in our Todo App!!</p>
  </article>  
  <article class="slide">
    <h2>Todo Take Home Challenge!</h2>
    <h3>Try adding these new features on your own:</h3>
    <ul>
      <li>Click "!" icon to prioritize a todo</li>
      <li>Or make the "!" a select input to set multiple priority levels</li>
      <li>Tags to categorize todos (w/ color scheme)</li>
      <li>Filter by tags & priority</li>
      <li>Sort by alpha, priority etc</li>
      <li>Recycle bin to recover deleted todos</li>
      <li>Timestamps: date created & date completed</li>
      <li>Add an initial fetch call to populate inital todos</li>
      <li>use title attr to add descriptor tooltips for each feature</li>
    </ul>
  </article>
  <article class="slide">
    <h2>Everything's a List!</h2>
    <p><small>(Ok, maybe not eerything)</small></p>
    <ul>
      <li>Shopping Cart</li>
      <li>Music/video Playlist</li>
      <li>Photo Gallery</li>
      <li>Code Bug Tracker</li>
      <li>Chat Window</li>
      <li>Forum</li>
      <li>Blog post site</li>
      <li>News Aggregator Site</li>
    </ul>
  </article>
  <article class="slide">
    <h2>Refactoring</h2>
    <p>Is it a change that is:</p>
    <ol>
      <li>Fundamental to the business logic</li>
      <li>Cosmetic</li>
    </ol>
    <p>Given that where will the change need to happen? M? V? C?</p>
    <p>Is there an implementation that's already there that is similar? If so use that as a starting point and make your code conform to the style of that implementation to keep the codebase consistent.</p>
  </article>
  
</section>

<section>
	<header class="slide">
    <h2>Async Redux</h2>
		<h1>The Leading <strong>State Managment</strong> Library for React Apps</h1>
	</header>

  <article class="slide">
    <h2>Async Side Effects are tricky</h2>
    <p>So far we've seen how to use Redux with synchronous side effects.</p>
    <p>But what if we want our side effect to update a database? or use a Promise?</p>
    <p>We'll need a way for our Reducer function to do asynchronous operations, and still update the Store correctly and re-render our components correctly. Despite the time lags.</p>
  </article>

	<article class="slide">
    <h2>Thunks</h2>
    <p>What's a Thunk?</p>
    <ul>
      <li>A fancy word for a pattern to handle asynchronous logic</li>
      <li>Thunks are just functions that return another function (Remember Currying?)</li>
      <li>Because Thunks are curried they let us call the returned function at a later time.</li>
    </ul>
	</article>
  <article class="slide">
    <h2>Async Redux</h2>
    <p>Redux with database side effects</p>
    <img src="img/Thunks.png" alt="">
  </article>
  <article class="slide">
    <h2>Redux Toolkit</h2>
    <p>The new & improved way to Redux!</p>
    <p>Simpler, less boilerplate & with nice new features!</p>
  </article>
  <article class="slide">
    <h2>Redux Toolkit <sup><a href="https://redux-toolkit.js.org/">Docs</a></sup></h2>
    <ul>
      <li><code>configureStore()</code>: simplifies <code>createStore</code> with good default configuration. Combines slice reducers, adds Redux middleware, uses redux-thunk & Redux DevTools by default.</li>
      <li><code>createReducer()</code>: supplies a lookup table of action types to case reducer functions, instead of switch statements. Uses the <code>immer</code> library underneath.</li>
      <li><code>createAction()</code>: generates an action creator function for the given action type string.</li>
      <li><code>createSlice()</code>: accepts an object of reducer functions, a slice name, and an initial state value, and automatically generates a slice reducer with corresponding action creators and action types.</li>
      <li><code>createAsyncThunk</code>: accepts an action type string and a function that returns a promise, and generates a thunk that dispatches <code>pending/fulfilled/rejected</code> action types based on that promise</li>
      <li><code>createEntityAdapter</code>: generates a set of resusable reducers and selectors to manage normalized data in the store</li>
      <li><code>createSelector</code> utility is exported from the Reselect library</li>
    </ul>
  </article>
  <article class="slide">
    <h2>RTK Query</h2>
    <p><a href="https://redux-toolkit.js.org/rtk-query/overview">RTK Query overview</a></p>
  </article>
  
  <article class="slide">
    <h2>Immer <sup><a href="https://immerjs.github.io/immer/">Docs</a></sup></h2>
    <p>Executing Immutable compliant state updates with assignment operations!!</p>
    <p>But you said we weren't suppossed to use assignments!?</p>
    <p>Correct, But Immer.js lets us write mutable looking code, and it intercepts that code and translates it into code that transacts with our Redux store immutably. </p>
    <p>Immer creates a "Draft" which is the object that we change mutably. Then Immer is able to infer what immutable updates it should do from that "Draft".</p>
  </article>
</section>

<footer class="slide" title="The End">
  <h2>Thanks!</h2>
</footer>

<script src="../lib/inspire.js"></script>

</body>
</html>
