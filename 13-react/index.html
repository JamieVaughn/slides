<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="MCC Web Design & Development Slides">
	<meta name="author" content="Jamie Vaughn">
  <title>Template</title>
  <!-- Inspire css -->
	<link href="../lib/inspire.css" rel="stylesheet" />
	<link href="../lib/theme.css" rel="stylesheet" />
	<link href="../lib/talk.css" rel="stylesheet" />
	<link href="../lib/utils.css" rel="stylesheet" />

  <!-- Custom css -->
</head>
<body class="language-markup" data-prism-plugins="normalize-whitespace" data-duration="55">

<header id="intro" class="slide">
	<h1>
		Web Design & Development
	</h1>
	<h2>
		React
	</h2>
	<p class="attribution">MCC: Section 3</p>
</header>
<section>
	<header class="slide">
		<h3>React</h3>
		<h1>Most Popular JS Framework</h1>
	</header>
	<article class="slide">
		<h2>Why Frameworks?</h2>
		<ul>
			<li>Automate the repetitive stuff</li>
			<li>Convention over Configuration</li>
			<li>Make doing the right things easy</li>
			<li>Consistent Contributions on a Dev Team</li>
		</ul>
	</article>
	<article class="slide">
		<h2>Rich Harris, "Rethinking Reactivity" 2019</h2>
		<img src="img/frameworks_organize_minds.png" alt="Rich Harris on Frameworks">
	</article>
	<article class='slide'>
		<h2>UX vs. DX</h2>
		
		<strong>UX Tools:</strong>
		<ul>
			<li>Accessibility tools</li>
			<li>Design tools & process (Adobe, Figma etc)</li>
			<li>Affordances</li>
			<li>User Research/Interviews</li>
		</ul>
		<strong>DX Tools:</strong>
		<ul>
			<li>Frameworks</li>
			<li>Automated Linting / Formatting</li>
			<li>Version Control</li>
		</ul>
	</article>
	<article class="slide">
		<h2>Which to Prioritize?</h2>
		<p><strong>UX</strong>: User Experience ⟺ <strong>DX</strong>: Developer Experience</p>
		<p>UX <strong>vs.</strong> DX?</p>
		<p>OR</p>
		<p>UX <strong>and</strong> DX</p>
	</article>

	<article class="slide">
		<h2>Breaking the Mold - <a href="https://youtu.be/nYkdrAPrdcw?t=623">2013</a></h2>
		<ul>
			<li class='nolist'><strong>Facebook releases React</strong></li>
			<li>Synthetic Event Handling</li>
			<li>Declarative Syntax</li>
			<li>Composable Components</li>
			<li>Reusable Code</li>
			<li>Functional Programming Style</li>
			<li>Conceptual Simplicity & Speed</li>
		</ul>
	</article>
	<article class="slide">
		<h2>More predictable apps!</h2>
		<div class="flex">
			<img src="img/predictability.png" alt="">
			<ul>
				<li>Handles Rendering wtih a Scheduler (Game Loop)</li>
				<li>One way data flow (Flux Pattern)</li>
				<li>Virtual DOM & DOM Diffing (Fiber)</li>
				<li>Vanilla JS for Templating Logic (!DSL)</li>
			</ul>
		</div>
	</article>

	<article class="slide">
		<h2>Disadvantages</h2>
		<ul>
			<li>Diverges from conventional MVC idea</li>
			<li>Learning Curve w/ Build Tooling</li>
			<li>Difficult Typescript Support</li>
			<li>Overwhelming library ecosystem</li>
		</ul>
	</article>

	<article class='slide'>
		<h2>Redefining Separation of Concerns</h2>
		<img src="./img/seperate_by_component.png" height='600px' alt="directory tree">
	</article>
	<article class="slide">
		<h2>JSX</h2>
		<p>React's syntax for defining View templates</p>
		<p><a href="https://babeljs.io/repl/">Transpiler</a></p>
		<img src="img/jsx.png" alt="jsx example">
	</article>
	<article class="slide">
		<h2>Strength of Components</h2>
		<img src="img/Build_one.png" height='600px' alt="component architecture">
	</article>
	<article class='slide'>
		<h2>Directory Structure Comparison</h2>
		<div class='flex most-height'>
			<img src="./img/CompvsConc.png" height='500px' alt="directory tree">
			<ul>
				<li class='nolist'><strong>Components</strong></li>
				<li>One component per folder (or file)</li>
				<li>Colocates Component Specific JS </li>
				<li>Colocates CSS for easy maintenance</li>
				<li>Easy to match a bug in a component with the code that's causing it</li>
				<li>Inline styles on components can improve Time to Paint</li>
				<li>Compiler injects the inline styles, not the Dev</li>

				<li class='nolist'><strong>Concerns</strong></li>
				<li>All CSS is jumbled together (same with JS)</li>
				<li>Hard to find code causing a bug based on View</li>
			</ul>
		</div>
	</article>
	<article class="slide">
		<h2>React Project Directory</h2>
		<img src="./img/reactModal.png" alt="CSS inheritence meme">
	</article>

	<article class="slide">
		<h2>What does a React Component look like?</h2>
		<div class="flex most-height align">
			<img src="img/comp_diagram.png" height='600px' alt="Component diagram">
			<pre class="language-js"><code>function MyComponent (props) {
  const defaultName = 'Buddy'
  const handleClick = e => console.log(e)
  return (
    &lt;div onClick={handleClick}>
      &lt;h1>Hello&lt;/h1>
      &lt;h2>{props.name ?? defaultName}!&lt;/h2>
    &lt;/div>
  )
}</code></pre>
		</div>
	</article>

	<article class="slide">
		<h2>Trees of Components</h2>
		<ul>
			<li>Model + Component => DOM Fragment</li>
			<li>Connected Components in a Hierarchy => App</li>
		</ul>
		<img src="img/component_tree.png" height='400px' alt="component tree">
	</article>
	<article class="slide">
		<h2>Composing Components</h2>
		<div class="flex most-height">
			<img src="img/Search_component.png" alt="Search component">
			<img src="img/jsx.png" alt="jsx">
		</div>
	</article>
	<article class="slide">
		<h2>Define Components separately</h2>
		<p>While its perfectly fine to nest components when composing them (i.e invoking them)</p>
		<p>Do not nest components when defining them</p>
			<strong>Incorrect way:</strong>
		</div>
			<pre class="language-js wrong"><code>function ParentComponent() {
  // Don't define a component inside a component:
  const ChildComponent = () => &lt;div>Hello&lt;/div> 

  return &lt;ChildComponent />
}</code></pre>
			
			<strong>Correct way:</strong>

			<pre class="language-js correct"><code>const ChildComponent = () => &lt;div>Hello&lt;/div>

function ParentComponent() {
  return &lt;ChildComponent />
}</code></pre>

	</article>
	<article class="slide">
		<h2>Importing Component Files</h2>
		<img src="img/full_react_file.png" height='600px' alt="Full react component file">
	</article>

	<article class="slide">
		<h2>Remember MVC?</h2>
		<img src="img/mvc.png" height='600px' alt="">
	</article>
	<article class="slide">
		<h2>The Problem with MVC</h2>
		<p>Difficult to Predict as it scales</p>
		<img src="img/mvc_tangle.png" height='600px' alt="">
	</article>
	<article class="slide">
		<h2>A Simpler Model</h2>
		<img src="img/generic_system.png" height='600px' alt="">
	</article>

	<article class="slide">
		<h2>Flux Architecture</h2>
		<img src="img/flux1.png" alt="">
	</article>
	<article class="slide">
		<h2>Flux Architecture</h2>
		<img src="img/flux2.png" alt="">
	</article>
	<article class="slide">
		<h2>Example Flux Diagram</h2>
		<img src="img/example_forum_tree.png" height='600px' alt="">
	</article>

	<article class="slide">
		<h2>Back to the Future</h2>
		<ul>
			<li>90's Server Side Rendering: When data changes, refresh the page!</li>
			<li>When data changes React re-renders the component</li>
			<li>Referentially transparent functions:</li>
			<ul>
				<li>State fully describes UI at any point in time (not path dependent)</li>
				<li>Easy to predict UI for a given input</li>
				<li>Easy to test</li>
			</ul>
		</ul>
	</article>
	<article class="slide">
		<h2>Kind of Like a Game Engine</h2>
		<img src="img/Game_Loop.png" height='400px' alt="React is like Doom 3 game">
		<ul>
			<li>Inefficient to rebuild entire DOM everytime</li>
			<li>Also would lose implicit DOM state each re-render (scroll, focus)</li>
		</ul>
	</article>
	<article class="slide">
		<h2>Virtual DOM</h2>
		<p>
			<strong>React Builds a new Virtual DOM Subtree</strong> 
			using the 
			<a href="https://reactjs.org/docs/reconciliation.html">The Reconciliation Algorithm</a>
		</p>
		<ul>
			<li>Diffs it with the old one</li>
			<li>Computes the minimal set of DOM mutations and puts them in a queue</li>
			<li>Scheduler batch executes all computed updates</li>
		</ul>
		<p></p>
	</article>

	<article class="slide">
		<h2>V-DOM & Direct DOM Manipulation</h2>
		<p>
			<blockquote>React is unaware of changes made to the DOM outside of React. It determines updates based on its own internal representation, and if the same DOM nodes are manipulated by another library, React gets confused and has no way to recover.</blockquote>
		</p>
		<cite><a href="https://reactjs.org/docs/integrating-with-other-libraries.html">React Docs</a></cite>
		<p>In general, it's not recommended to mix other DOM manipulation libraries with a Virtual DOM & its Reconciliation Process. (although it is possible with extra work).</p>
	</article>

	<article class="slide">
		<h2>Rendering in React in Depth</h2>
		<p><a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/">Article</a></p>
		<ul>
			<li>Render Phase: work of rendering components/calculating changes</li>
			<ul>
				<li>Rendering Components means describing the UI in data format (as js objects)</li>
				<li>Reconciliation</li>
				<li>Concurrent Mode chunks/debounces/forfeits Render Phase work only</li>
				<li>Render Batching: these trigger Queued Renders so they may be async: 
					<ul>
						<li>useState setters</li>
						<li>useReducer dispatches</li>
						<li>this.setState()</li>
						<li>this.forceUpdate()</li>
					</ul>
				</li>
			</ul>
			<li>Commit Phase: applying those changes to the DOM</li>
			<ul>
				<li>Update all Refs</li>
				<li>Run didMount, didUpdate lifecycles & useLayoutEffect synchronously</li>
				<li></li>
			</ul>
			<li>Passive Effects Phase: runs useEffect hooks</li>
			<li></li>
			<li></li>
		</ul>
	</article>
	<article class="slide">
		<h2>Commit Phase Details</h2>
		<p>
			There's some additional edge cases inside of the commit-phase lifecycle methods: componentDidMount, componentDidUpdate, and useLayoutEffect. These largely exist to allow you to perform additional logic after a render, but before the browser has had a chance to paint. In particular, a common use case is:
		</p>
		<ul>
			<li>Render a component the first time with some partial but incomplete data. The initial "partial" rendered UI won't be visible to the user - only the "final" UI will show up</li>
			<li>In a commit-phase lifecycle, use refs to measure the real size of the actual DOM nodes in the page</li>
			<li>Set some state in the component based on those measurements</li>
			<li>Immediately re-render with the updated data</li>
		</ul>
	</article>
	<article class="slide">
		<h2>Standard Render Behavior</h2>
		<p><a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#standard-render-behavior">Explanation</a></p>
		<p>There's a rendred component tree of A > B > C > D. The user clicks a button in B that increments a counter:</p>
		<ul>
			<li>We call setState() in B, which queues a re-render of B.</li>
			<li>React starts the render pass from the top of the tree</li>
			<li>React sees that A is not marked as needing an update, and moves past it</li>
			<li>React sees that B is marked as needing an update, and renders it. B returns <C /> as it did last time.</li>
			<li>C was not originally marked as needing an update. However, because its parent B rendered, React now moves downwards and renders C as well. C returns <D /> again.</li>
			<li>D was also not marked for rendering, but since its parent C rendered, React moves downwaard and renders D too.</li>
		</ul>
		<p>This means that calling setState() in your root <App> component, with no other changes altering the behavior, will cause React to re-render every single component in the component tree.</p>
	</article>

	<article class="slide">
		<h2>Let's make a Simple React Site</h2>
		<p>Webpages with React!</a></p>
		<p>Reproduce this website layout with <strong>presentational components!</strong></p>
		<p><a href="https://codepen.io/heliocrat/pen/RwpGLZb">Codepen</a></p>
		<p><a href="https://reactjs.org/docs/rendering-elements.html">Docs on Rendering Simple Elements</a></p>
	</article>
	<article class="slide">
		<h2>Adding Props to our Component</h2>
		<p>Props let us customize our Functional/Presentationl Components</p>
		<p><a href="https://reactjs.org/docs/components-and-props.html">Components & Props</a></p>
		<pre class="language-js"><code>
function PresentationalComponent(props) {
  return (
    &lt;div className=`${props.css}` data-id={props.id}>
      {props.flag ? props.content : 'Default Content'}
    &lt;/div>
  )
}
		</code></pre>
	</article>

	<article class="slide">
		<h2>Adding Events to our Component</h2>
		<h3><a href="https://reactjs.org/docs/events.html#gatsby-focus-wrapper">Synthetic Events</a></h3>
		<p>Using events & event handlers in React is slightly different that conventional DOM Events</p>
		<pre class="language-js"><code>
function EventComponent(props) {
	handleClick = (e) => {
		console.log(e)
	}
	return (
		&lt;div onClick={handleClick}>
			Click Me!
		&lt;/div>
	)
}	</code></pre>
	</article>

</section>

<section>
	<header class="slide">
		<h3>React</h3>
		<h1>Hooks API</h1>
	</header>

	<article class="slide">
		<h2>React Hooks</h2>
		<p><a href="https://reactjs.org/docs/hooks-reference.html">Available Hooks</a></p>
		<strong>What can they do for us?</strong>
		<ul>
			<li>Manage State</li>
			<li>Handle Synchronization/LifeCycles</li>
			<li>Store References</li>
			<li>Create Reducers to help with Action Dispatching</li>
			<li>Optimize Component Execution</li>
			<li>And More!</li>
		</ul>
	</article>
	<article class="slide">
		<h2>Hooks APIs</h2>
		<p>Every Hook has its own unique API, so we need to go through each one by one.</p>
		<p>Starting with <code>useState</code></p>
	</article>

	<article class="slide">
		<h2>Managing Internal State</h2>
		<p>With Hooks!</p>
		<p>The most important thing is to never mutate state directly.</p>
		<p>Mutate state with <a href="https://reactjs.org/docs/hooks-state.html"><code>useState(state)</code></a></p>
		<pre class="language-js"><code>const MyComponent = props => {
  const [clicks, setClicks] = React.useState(0)
	// clicks += 1  ⇦don't mutate or reassign directly
  return (
    &lt;button onClick={() => setClicks(clicks+1)}>
      First Name: {clicks}
    &lt;/button>
  )
}
</code></pre>
	</article>

	<article class="slide">
		<h2>Rules of Hooks</h2>
		<p><a href="https://reactjs.org/docs/hooks-rules.html">Reactjs.org</a></p>
		<p><a href="https://reactjs.org/docs/hooks-faq.html">Hooks FAQ</a></p>
	</article>

	<article class="slide">
		<h2>Let's make Something with State</h2>
		<p>A Dice Rolling App!</p>
	</article>


	<article class="slide">
		<h2>React Fragments</h2>
		<p><a href="https://reactjs.org/docs/fragments.html">fragments</a></p>
		<pre class="language-jsx"><code>const MyComponent = () => {
  return (
    &lt;> // React JSX Fragment
      &lt;div>hello&lt;/div>
      &lt;div>world&lt;/div>
    &lt;/>
  )
}</code></pre>
	</article>

	<article class="slide">
		<h2>Prop Types</h2>
		<p>Type checking tool that provides helpful errors & warnings during development when incorrect props are passed to a component</p>
		<ul>
			<li><a href="https://reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper">Prop Types Options</a></li>
			<li><a href="https://www.npmjs.com/package/prop-types">npm docs</a></li>
			<li><code style='font-size: 80%;'>&lt;script src="https://unpkg.com/prop-types@15.6/prop-types.js">&lt;/script></code></li>
		</ul>
		<pre class="language-js"><code>import PropTypes from 'prop-types';

MyComponent.propTypes = { 
  handleClick: PropTypes.func.isRequired 
}</code></pre>
	</article>

	<article class="slide">
		<h2>Let's Revisit Dragon Clicker with React!</h2>
		<p><a href="https://github.com/JamieVaughn/react-clicker">React Dragon Clicker!</a></p>
	</article>

	<article class="slide">
		<h2>Hooks Way vs Class Way</h2>
		<p>The legacy way to create React Components uses <code>React.Component</code></p>
		<div class="flex tight align">
			<pre class="language-js"><code>const MyComponent = ({message = 'Hi'}) => (
	&lt;div>A Class Component: {props.message}&lt;/div>
)</code></pre>
		<pre class="language-js"><code>class MyComponent extends React.Component {
  constructor(props) {
    super(props)
  }
  render() {
    return (
      &lt;div>A Class Component: {this.props.message}&lt;/div>
    )
  }
}</code></pre>
		</div>
		<div class="flex tight">
			<h4 style='margin: 0'>Rendering Either Type to the DOM</h4>
			<h4 style='margin: 0'>Providing Default Parameters</h4>
		</div>
		<script>
			function findSlash(node, flag) {
				let el = node.querySelector('code span:nth-child(5)')
				el.innerText = flag ? 'message={"Hello"} /' : '/'
			}
		</script>
		<div class="flex tight">
			<pre class="language-js" onmouseenter="findSlash(this, true)" onmouseleave="findSlash(this)"><code>
ReactDOM.render(
  &lt;MyComponent />, document.getElementById('root')
)</code></pre>
<pre class="language-js"><code>MyComponent.defaultProps = {
  message: 'Hi'
}</code></pre>
		</div>
		
	</article>
	<article class="slide">
		<h2>Stateful Components</h2>
		<ul>
			<li>The React Class Components used to be the only way to implement internal State <sup><a href="https://reactjs.org/docs/react-without-es6.html#declaring-default-props">React before ES6</a></sup></li>
		  <li>But now we can have state in a function with the <code>useState</code> Hook.</li>
		</ul>
		<div class="flex most-height align" >
			<pre class="language-js"><code>class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      name: 'Bob'
    }
  }
  render() {
    return &lt;div>First Name: {this.state.name}&lt;/div>
  }
}</code></pre>
<pre class="language-js"><code>const MyComponent = props => {
  const [name, setName] = React.useState('Bob')
  return &lt;div>First Name: {name}&lt;/div>
}</code></pre>
		</div>
	</article>

	<article class="slide">
		<h2>Event Handling in Class Components</h2>
		<p>The most important thing is to never mutate state directly. Mutate state with <code>this.setState()</code></p>
		<pre class="language-js"><code>class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {name: 'Bob'}
    this.changeName = this.changeName.bind(this);
    this.addLastName = this.addLastName.bind(this);
  }
  changeName() { this.setState({name: 'Alice'}) }
  addLastName() { this.setState(prev => ({name: prev + 'Smith'})) }
  render() {
    return (
      &lt;p>{this.props.name}&lt;/p>
      &lt;p>{this.state.name}&lt;/p>
      &lt;button onClick={this.changeName}>Change Name&lt;/button>
      &lt;button onClick={this.addLastName}>Add Last Name&lt;/button>
    )
  }
}</code></pre>
	</article>

	<article class="slide">
		<h2>Hook/Class Refactoring Challenge</h2>
		<p>Let's practice refactoring React Components!</p>
		<p>Refactor a Hook component into a Class Component and Vice Versa!</p>
	</article>

	<article class="slide">
		<h2>The <code>useRef</code> Hook <sup><a href="https://reactjs.org/docs/hooks-reference.html#useref">Docs</a></sup></h2>
		<p>This gives you a direct reference to some value that persists between renders.</p>
		<p>Most commonly used to hold references to DOM nodes</p>
		<p>Must call the <code>current</code> property to retreive the value</p>
		<pre class="language-js"><code>const MyComponent = props => {
  let div = useRef(null)
  let input = useRef(null)
  return (
    &lt;div onClick={() => console.log(div.current, input.current.value)}> 
      &lt;div type="text" ref={div}>Hello&lt;/div>
      &lt;input type='text' ref={input} />
    &lt;/div>
  );
}</code></pre>
	</article>

	<article class="slide">
		<h2>Forms in React</h2>
		<p>Controlled vs. Uncontrolled Forms</p>
		<div class="flex">
			<ul>
				<li style='list-style: none;'><strong>Controlled Forms (recommended):</strong></li>
				<li>React tracks form state</li>
				<li>Utilizes Flux Pattern</li>
				<li>Uses <code>onChange</code> event handler and re-renders with every input</li>
				<li>Better javascript validation control</li>
				<li>Can be tedious for large forms</li>
			</ul>
			<ul>
				<li style='list-style: none;'>Uncontrolled Forms (fallback):</li>
				<li>DOM tracks form state</li>
				<li>Form state is held implicitly in DOM state</li>
				<li>Need to use either <code>useRef</code> Hook or the Synthetic Event to retreive DOM state</li>
			</ul>
		</div>
	</article>
	<article class="slide">
		<h2>More on <code>useRef</code></h2>
		<p>Be careful not to mutate the ref since it is not tracked by the virtual Dom</p>
		<p>The values of refs persist (specifically the current property) throughout render cycles, <strong>but do not trigger a re-render.</strong></p>
		<p><code>useRef</code> can also be used to hold external variables or instance variables</p>
		<p><code>useRef</code> will be more useful in combination with <code>useEffect</code></p>
		<p><a href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables">Example</a> / <a href="https://blog.logrocket.com/usestate-vs-useref/">Article</a></p>
	</article>

	<article class="slide">
		<h2>Let's Code some Forms in React!</h2>
		<p>Controlled Form</p>
		<p>Uncontrolled Form</p>
		<p><a href="https://felixgerschau.com/react-hooks-form-validation-typescript/">React Hooks form validation patterns</a></p>
	</article>

	<article class="slide">
		<h2>Lifting State Up</h2>
		<p>We can't share state between siblings or up to parents with <code>useState</code></p>
		<p>So we have to "Lift State Up" - Declare the state higher in the Component Tree so it can be passed down the tree</p>
		<img src="img/component_tree.png" alt="Component Tree">
	</article>

	<article class="slide">
		<h2>Prop Drilling</h2>
		<p>We can pass state down the Component Tree with a concept called Prop Drilling</p>
		<div class='flex' style='margin: 0; align-items: flex-end;'><pre class="language-js"><code>&lt;App img={img} user={user} /></code></pre><span>↴</span></div>
		<div class='flex' style='margin: 0; align-items: flex-end;'><pre class="language-js" style='margin-left: 20%'><code>&lt;Main img={img} user={user} /></code></pre><span>↴</span></div>
		<div class='flex' style='margin: 0; align-items: flex-end;'><pre class="language-js" style='margin-left: 35%'><code>&lt;User img={img} user={user} /></code></pre><span>↴</span></div>
		<div class='flex' style='margin: 0;'><pre class="language-js" style='margin-left: 60%'><code>&lt;Avatar img={img} /></code></pre><span></span></div>
	</article>

	<article class="slide">
		<h2>Thinking in React <sup><a href="https://reactjs.org/docs/thinking-in-react.html">Docs</a></sup></h2>
		<p>Using Component Architecture to Build Apps</p>
		<ul>
			<li>Build a component Hierarchy from a Mock</li>
			<li>Layout the components in React</li>
			<li>Think about where the State Should live</li>
		</ul>
		<div class="flex">
			<img src="img/Search_component.png" alt="">
			<ul>
				<li><code>&lt;FilterableProductTable /></code></li>
				<ul>
					<li><code>&lt;SearchBar /></code></li>
					<li><code>&lt;ProductTable /></code></li>
					<ul>
						<li><code>&lt;ProductCategoryRow /></code></li>
						<li><code>&lt;ProductRow /></code></li>
					</ul>
				</ul>
			</ul>
		</div>
	</article>

	<article class="slide">
		<h2>The <code>useEffect</code> Hook</h2>
		<p>This is for keeping components in-sync with any change to our model (state, props, refs or any data)</p>
		<p>It essentially sets up a watcher (or listener) on any arbitrary variable</p>
		<p>Then it will run the callback inside when a change is detected</p>
		<pre class="language-js"><code>function MyComponent (props) {
  useEffect(() => {
    // do side effects (runs if `dependency` changes)
    return () => {
      // clean up references (runs if removed from DOM)
    }
  }, [dependency])

  return &lt;div>useEffect hook is awesome!&lt;/div>
}
		</code></pre>
	</article>
	<article class="slide">
		<h2><code>useEffect</code> Example <sup><a href="https://jsonplaceholder.typicode.com/todos/1">todo</a></sup></h2>
		<pre class="language-js"><code>function MyComponent() {
  const [id, setId] = useState()
  const [todo, setTodo] = useState(null)
  useEffect(() => {
    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
      .then(resp => resp.json())
      .then(data => {
        setTodo(data);
      });
  }, [id]);
  return (
    &lt;>
      &lt;input type='number' onChange={e => setId(e.target.value)}/>
	  &lt;div>{JSON.stringify(todo)}&lt;/div>
    &lt;/>
  )
}</code></pre>
	</article>
	<article class='slide'>
		<h2>useEffect as an Event Listener</h2>
		<p><a href="https://wjv.io/blog/posts/use_effect.html">React's useEffect as an "Event Listener"</a></p>
		<pre class="language-js"><code>useEffectListener([foo], () => {
  // do side effects
})
		
addEventListener('click', e => {
  // do side effects
})
		</code></pre>
	</article>
	<article class="slide">
		<h2>Syncing Data in React class components</h2>
		<div class="flex full-height align">
			<ul>
				<li class="nolist"><strong>Class components use <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">"Lifecycle Methods"</a></strong></li>
				<li><p><a href="https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class">Adding Lifecycle Methods to a Class</a></p></li>
				<li><p><a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle">Component Lifecycle methods</a></p></li>
				<li><code>componentDidMount</code></li>
				<li><code>componentDidUpdate</code></li>
				<li><code>componentWillUnmount</code></li>
				<li><code>componentDidCatch</code></li>
				<li><code>shouldComponentUpdate</code></li>
			</ul>
		<pre class="language-js"><code>class MyComponent extends React.Component {
  constructor(props) { super(props) }
  componentDidMount() { // runs after added to DOM
  }
  componentDidUpdate() { // runs when updated
  }
  componentWillUnmount() { // runs before removal from DOM
  }
  componentDidCatch() { // runs if encountering an error
  }
  shouldComponentUpdate() { // run a check & return true or false
    // if returns false, then render() will not run
  }
  render() {
    return &lt;div>Hello Lifecycle Methods!&lt;/div>
  }
}
		</code></pre>
	</div>
	</article>
	<article class="slide">
		<h2>Lifecycle Method Equivalents</h2>
		<div class="flex">
			<ul style='flex-shrink: 1.5'>
				<li class="nolist"><code>componentDidMount</code></li>
				<li class="nolist"><code>componentDidUpdate</code></li>
				<li class="nolist"><em style="color: orangered">No equivalent</em></li>
				<li class="nolist"><code>componentWillUnmount</code></li>
				<li class="nolist"><code>componentDidCatch</code></li>
				<li class="nolist"><code>shouldComponentUpdate</code></li>
			</ul>
			<ul style='flex-shrink: 2'>
				<li class="nolist">⟺</li>
				<li class="nolist">⟺</li>
				<li class="nolist">⟺</li>
				<li class="nolist">⟺</li>
				<li class="nolist">⟺</li>
				<li class="nolist">⟺</li>
			</ul>
			<ul style='flex-grow: 2'>
				<li class="nolist">Empty dependency array</li>
				<li class="nolist">No dependency array</li>
				<li class="nolist">Populated dependency array</li>
				<li class="nolist">Return callback</li>
				<li class="nolist"><em style="color: orangered">No direct equivalent</em> <code>try/catch</code></li>
				<li class="nolist">Normal control flow <code>if/else</code></li>
			</ul>
		</div>
	</article>
	<article class="slide">
		<h2>useEffect Implementations</h2>
		<pre class="language-js"><code>import React, { useState, useEffect } from 'react';
			const Counter = ({ someProps }) => {
				const [count, setCount] = useState(0);
				useEffect(() => {
					console.log('componentDidMount - fires once at the beginning');
					return () => {
						console.log('componentWillUnmount - fires once at the end');
					}
				}, []);
				useEffect(() => {
					console.log('ComponentDidUpdate - fires every update (not recommended)')
				})
				useEffect(() => {
					console.log('only fires when `count` changed');
				}, [count]);
				useEffect(() => {
					console.log('only fires when `someProps` changed');
				}, [someProps]);
				return (
					&lt;button onClick={() => { setCount(count + 1); }}>
						Count: {count}
					&lt;/button>
				);
			};
			</code></pre>
	</article>
	<article class="slide">
		<h2>Comparing useEffect with Lifecycle Methods</h2>
		<img src="img/useeffect_lifecycle.png" alt="">
	</article>
	<article class="slide">
		<h2>Code Along</h2>
		<p>Let's try out useEffect in a small App!</p>
		<p>(and we'll see how it compares to Lifecycle Methods)</p>
	</article>

	<header class='slide'>
		<h3>React</h3>
		<h1>Other APIs</h1>
	</header>

	<article class="slide">
		<h2>React Profiler</h2>
		<p><a href="https://reactjs.org/docs/profiler.html">Profiler API</a></p>
	</article>

	<article class="slide">
		<h2>React Developer Tools</h2>
		<p><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Browser Extension</a></p>
	</article>

	<!-- <article class="slide">
		<h2>Render Props</h2>
		<p>A render prop is a prop that renders a View... in other words: it's a component that is passed as a prop.</p>
		<p><a href="https://reactjs.org/docs/render-props.html">Using Render Props</a></p>
	</article> -->

	<article class="slide">
		<h2>Strict Mode</h2>
		<p>Strict Mode is a wrapping component that is used in development to help catch issues/bugs.</p>
		<p><a href="https://reactjs.org/docs/strict-mode.html">Using Strict Mode</a></p>
	</article>

	<article class='slide'>
		<h2>VS Code Snippets</h2>
		<p>Let's take advantage of VS Code's Snippets feature, so we can type out React components faster!</p>
		<p><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">Docs</a></p>
		<p><kbd>File/Code</kbd>><kbd>Preferences</kbd>><kbd>User Snippets</kbd> (then select language)</p>
		<pre class="language-json"><code>"Print to console Test": {
  "prefix": "log",
  "body": [
    "console.log('Hello ${1:name}!!!');",
    "$2"
  ],
  "description": "Log output to console"
}</code></pre>
	</article>

	<article class="slide">
		<h2>Children Props</h2>
		<code><code>&ltdiv>{props.children}&lt;/div></code></code>
		<p>The <code>children</code> prop is passed in automatically if you nest any jsx asa child of your component</p>
		<pre class="language-js"><code>function MyComponent () {
  return (
			&main>
				&lt;nav>A Nav Bar&lt;/nav>
			  {children}
				&lt;footer>a footer&lt;/footer>
			&lt;/main>
	 )</code></pre>
		<pre class="language-js"><code>return (
   &lt;MyComponent>
			&div>This child element gets passed through into MyComponent&lt;div>
	 &lt;/MyComponent>
)</code></pre>
	</article>

	<article class="slide">
		<h2>The App Shell</h2>
		<strong>It is the part of the UI that persists when navigating around the app.</strong>
		<p>An application shell architecture makes the most sense for apps and sites with relatively unchanging navigation but changing content.</p>
		<p>Structure your app for a clear distinction between the page shell (the persistent UI) and the dynamic content.</p>
		<p><a href="https://developers.google.com/web/fundamentals/architecture/app-shell">App Shell Model</a></p>
	</article>

	<article class="slide">
		<h2>Building with Vite.js</h2>
		<p><a href="https://vitejs.dev/">Vite Docs</a></p>
	</article>

	<article class="slide">
		<h2>Let's Build a Layout with Vite.js</h2>
		<p><a href="https://vitejs.dev/guide/#browser-support">Get Started with Vite!</a></p>
	</article>

	<article class='slide'>
		<h2>Take Home Challenge!</h2>
		<p>Try out the "Tutorial Fade" technique on this:</p>
		<p><a href="https://reactjs.org/tutorial/tutorial.html">React Tic Tac Toe Tutorial</a></p>
	</article>

</section>

<section>
	<header class='slide'>
		<h3>React</h3>
		<h1>Advanced Hooks</h1>
	</header>
	<article class="slide">
		<h2>useContext</h2>
		<p>Share data without passing props</p>
	</article>
	<article class="slide">
		<h2>useReducer</h2>
		<p>Create an action reducer function & its dispatcher with less boilerplate</p>
		<p>Its a different way to manage state updates.</p>
	</article>
	<article class="slide">
		<h2>useLayoutEffect</h2>
		<p>Just like useEffect, but runs after the virtualDOM is mounted</p>
	</article>
	<article class="slide">
		<h2>useMemo</h2>
		<p>Memoize a components returned jsx (i.e. its <strong>View</strong> template output)</p>
		<p>Memoize means it caches the result of the function call so it can use it directly if the parameters didn't change.</p>
	</article>
	<article class="slide">
		<h2>useCallback</h2>
		<p>Similar to useMemo, this will help with rendering performance optimization</p>
		<p>If you are passing a component down to multiple other components you can wrap it in <code>useCallback()</code> so that a single execution of the component is reused in all places instead of executed for each one.</p>
	</article>
	<article class="slide">
		<h2>A Couple Others</h2>
		<ul>
			<li><code>useImperativeHandle</code>: run imperative code on a useRef Element before it is passed down as a prop</li>
			<li><code>useDebugValue</code>: This is for help debugging/labeling custom Hooks with the React Dev Tools</li>
		</ul>
	</article>
	<article class="slide">
		<h2>Hooks Links</h2>
		<strong>Hooks Learning Guides</strong>
		<ul>
			<li><a href="https://react-hooks-cheatsheet.com/">Hooks cheat sheet</a></li>
			<li><a href="https://reactwithhooks.netlify.app/">React Docs with Hooks</a></li>
			<li><a href="https://wattenberger.com/blog/react-hooks">Thinking in React Hooks</a></li>
			<li><a href="https://www.youtube.com/watch?v=TNhaISOUy6Q">Hooks Overview video</a></li>
		</ul>
		<strong>Hooks Catalogs</strong>
		<ul>
			<li><a href="https://usehooks.com/">useHooks.com</a></li>
			<li><a href="https://antonioru.github.io/beautiful-react-hooks/">Beautiful Hooks</a></li>
			<li><a href="https://nikgraf.github.io/react-hooks/">Collection of Hooks</a></li>
		</ul>
	</article>
	<article class="slide">
		<h2>Custom Hooks!</h2>
		<p>We can actually go beyond the Basic React Hooks, and make our own hooks utilities!</p>
		<p>This is where React's feature of easy code reuse really shines.</p>
	</article>
	<article class="slide">
		<h2>Let's Create our own Hooks!</h2>
		<ul>
			<li><code>useFetch</code></li>
			<li><code>useInterval</code></li>
			<li><code>useLocalStorage</code></li>
			<li><code>usePreviousValue</code></li>
		</ul>
	</article>
	<article class="slide">
		<pre class="language-js"><code>export default function useMousePosition () {
  const [position, setPosition] = useState({ x: 0, y: 0 })

  useEffect(() => {
    const setFromEvent = e => setPosition({ x: e.clientX, y: e.clientY })
    window.addEventListener('mousemove', setFromEvent)

    return () => {
        window.removeEventListener('mousemove', setFromEvent)
    }
  }, [])

  return position
}</code></pre>
	</article>
	<article class="slide">
		<pre class="language-js"><code>const useOutsideClick = (ref, callback) => {
  const handleClick = e => {
    if (ref.current && !ref.current.contains(e.target)) {
    callback()
    }
  }

  useEffect(() => {
    document.addEventListener('click', handleClick)

    return () => {
      document.removeEventListener('click', handleClick)
    }
  })
}</code></pre>
	</article>
</section>

<footer class="slide" title="The End">
	<h2>Thanks!</h2>
</footer>

<script src="../lib/inspire.js"></script>

</body>
</html>
